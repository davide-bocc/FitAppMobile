const { execSync } = require("child_process");
const mkdirp = require("mkdirp");
const fs = require("fs");
const path = require("path");

try {
  // 1. Crea cartella autolinking
  console.log("Creating autolinking folder...");
  const autolinkingDir = path.join(__dirname, "android/build/generated/autolinking");
  mkdirp.sync(autolinkingDir);

  // 2. Genera autolinking.json
  console.log("Generating autolinking.json...");
  execSync(`npx react-native config > ${path.join(autolinkingDir, "autolinking.json")}`, {
    stdio: "inherit",
  });

  // 3. Leggi il JSON generato
  const autolinkingJson = JSON.parse(
    fs.readFileSync(path.join(autolinkingDir, "autolinking.json"), "utf8")
  );

  // 4. Lista manuale dei moduli che ci interessano
  const modules = [
    "react-native-reanimated",
    "react-native-sound",
    "react-native-safe-area-context",
    "react-native-screens",
    "@react-native-picker/picker"
  ];

  // 5. Genera autolinking.cmake con check su percorsi
  const cmakePath = path.join(autolinkingDir, "autolinking.cmake");
  console.log("Generating autolinking.cmake...");

  let cmakeContent = `# Autogenerated autolinking.cmake\n# Only include modules that exist to prevent clean errors\n\n`;

  modules.forEach((mod) => {
    const modPath = path.resolve(__dirname, `node_modules/${mod}/android/build/generated/source/codegen/jni/`);
    if (fs.existsSync(modPath)) {
      cmakeContent += `add_subdirectory("${modPath}")\n`;
    } else {
      console.log(`⚠️  Module path does not exist, skipping: ${modPath}`);
    }
  });

  fs.writeFileSync(cmakePath, cmakeContent, "utf8");

  console.log("✅ Postinstall complete. autolinking.json and autolinking.cmake generated successfully.");

} catch (error) {
  console.error("❌ Error during postinstall:", error);
  process.exit(1);
}
